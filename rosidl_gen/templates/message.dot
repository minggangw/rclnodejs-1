// This file is automatically generated by Intel rclnodejs
//
// *** DO NOT EDIT directly
//

'use strict';

const StructType = require('ref-struct');
const ref = require('ref');
const ArrayType = require('ref-array');
const primitiveTypes = require('../../rosidl_gen/generator_primitive.js');

{{

let objectWrapper = it.spec.msgName + 'Wrapper';
let arrayWrapper = it.spec.msgName + 'ArrayWrapper';

let refObjectType = it.spec.msgName + 'RefStruct';
let refObjectArrayType = it.spec.msgName + 'RefStructArray';
let refArrayType = it.spec.msgName + 'RefArray';

if (it.spec.fields.length === 0) {
  /* Following rosidl_generator_c style, put a bool member named '_dummy' */
  it.spec.fields.push({
    "type": {
      "isArray": false,
      "pkgName": null,
      "type": "bool",
      "isDynamicArray": false,
      "stringUpperBound": null,
      "isUpperBound": false,
      "isPrimitiveType": true,
      "isFixedSizeArray": false,
      "arraySize": null
    },
    "name": "_dummy"
  });
} /* if */

function getPrimitiveNameByType(type) {
  if (type.type === 'bool') {
    return 'Bool';
  } else if (type.type === 'int8') {
    return 'Int8';
  } else if (type.type === 'uint8') {
    return 'UInt8';
  } else if (type.type === 'int16') {
    return 'Int16';
  } else if (type.type === 'uint16') {
    return 'UInt16';
  } else if (type.type === 'int32') {
    return 'Int32';
  } else if (type.type === 'uint32') {
    return 'UInt32';
  } else if (type.type === 'int64') {
    return 'Int64';
  } else if (type.type === 'uint64') {
    return 'UInt64';
  } else if (type.type === 'float64') {
    return 'Float64';
  } else if (type.type === 'float32') {
    return 'Float32';
  } else if (type.type === 'char') {
    return 'Char';
  } else if (type.type === 'byte') {
    return 'Byte';
  } else if (type.type === 'string') {
    return 'String';
  } else {
    return '';
  }
}

let primitiveBaseType = ['Bool', 'Int8', 'UInt8', 'Int16', 'UInt16', 'Int32', 'UInt32',
                         'Int64', 'UInt64', 'Float64', 'Float32', 'Char', 'Byte', 'String'];

let existedModules = [];

function isExisted(requiredModule) {
  return existedModules.indexOf(requiredModule) !== -1;
}

function isPrimitivePackage(baseType) {
  return primitiveBaseType.indexOf(baseType.type) !== -1;
}

function isStruct(type) {
  return !type.isPrimitiveType && !type.isArray;
}

function isStructArray(type) {
  return !type.isPrimitiveType && type.isArray;
}

function shouldRequire(baseType, fieldType) {
  let requiredModule = '{{=getPackageNameByType(fieldType)}}/{{=getJSFileNameByType(fieldType)}}';
  let shouldRequire = !isPrimitivePackage(baseType) && (fieldType.isArray || !fieldType.isPrimitiveType || isString(fieldType));

  if (shouldRequire && !isExisted(requiredModule)) {
    existedModules.push(requiredModule);
    return true;
  } else {
    return false;
  }
}

function isPrimitive(type) {
  return type.isPrimitiveType && !type.isArray;
}

function isPrimitiveArray(type) {
  return type.isPrimitiveType && type.isArray;
}

function isString(type) {
  return type.type === 'string' && !type.isArray;
}

function getWrapperNameByType(type) {
  if (type.isPrimitiveType) {
    return getPrimitiveNameByType(type) + 'Wrapper';
  } else {
    return type.type + 'Wrapper';
  }
}

function getJSFileNameByType(type) {
    if (type.isPrimitiveType) {
    return 'std_msgs__msg__' + getPrimitiveNameByType(type) + '.js';
  } else {
    return type.pkgName + '__msg__' + type.type + '.js';
  }
}

function getPackageNameByType(type) {
  if (type.isPrimitiveType) {
    return 'std_msgs';
  } else {
    return type.pkgName;
  }
}

}}

{{~ it.spec.fields :field}}
{{? shouldRequire(it.spec.baseType, field.type)}}
let {{=getWrapperNameByType(field.type)}} = require('../../generated/{{=getPackageNameByType(field.type)}}/{{=getJSFileNameByType(field.type)}}');
{{?}}
{{~}}

{{? it.spec.msgName === 'String'}}
const {{=refObjectType}} = primitiveTypes.string;
{{??}}
const {{=refObjectType}} = StructType({
  {{~ it.spec.fields :field}}
  {{? isPrimitive(field.type)}}
  {{=field.name}}: primitiveTypes.{{=field.type.type}},
  {{?? isPrimitiveArray(field.type)}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectArrayType,
  {{?? isStructArray(field.type)}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectType,
  {{?? true}}
  {{=field.name}}: {{=getWrapperNameByType(field.type)}}.refObjectType,
  {{?}}
  {{~}}
});
{{?}}

const {{=refArrayType}} = ArrayType({{=refObjectType}});

const {{=refObjectArrayType}} = StructType({
  data: ArrayType({{=refObjectType}}),
  size: ref.types.size_t,
  capacity: ref.types.size_t,
});

// Define the wrapper class
class {{=objectWrapper}} {
  constructor(other) {
    this._wrapperFields = {};
    if (typeof other === 'object' && other._refObject) {
      this._refObject = new {{=refObjectType}}(other._refObject.toObject());
      {{~ it.spec.fields :field}}
      {{? field.type.isArray || !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
      this._wrapperFields.{{=field.name}} =  new {{=getWrapperNameByType(field.type)}}(other._wrapperFields.{{=field.name}});
      {{?}}    
      {{~}}
    } else {
      this._refObject = new {{=refObjectType}}();
      {{~ it.spec.fields :field}}
      {{? field.type.isArray}}
      this._wrapperFields.{{=field.name}} = {{=getWrapperNameByType(field.type)}}.createArray();
      {{?? !field.type.isPrimitiveType || (field.type.type === 'string' && it.spec.msgName !== 'String')}}
      this._wrapperFields.{{=field.name}} = new {{=getWrapperNameByType(field.type)}}();
      {{?? it.spec.msgName === 'String'}}
      primitiveTypes.initString(this._refObject);
      {{?}}
      {{~}}
    }
  }
  
  static createArray() {
    return new {{=arrayWrapper}};
  }

  static get ArrayType() {
    return {{=arrayWrapper}};
  }

  static get refObjectArrayType() {
    return {{=refObjectArrayType}}
  }

  static get refObjectType() {
    return {{=refObjectType}};
  }

  toRawROS() {
    {{~ it.spec.fields :field}}
    {{? !isPrimitivePackage(it.spec.baseType) && !field.type.isPrimitiveType}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? !isPrimitivePackage(it.spec.baseType) && isString(field.type)}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? field.type.isArray}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?}}
    {{~}}
    return this._refObject.ref();
  }

  serialize() {

  }

  deserialize() {
    {{~ it.spec.fields :field}}
    {{? isStruct(field.type)}}
    this._wrapperFields.{{=field.name}}._refObject = this._refObject.{{=field.name}};
    this._wrapperFields.{{=field.name}}.deserialize();
    {{?}}    
    {{~}}
  }

  static type() {
    return {pkgName: '{{=it.messageInfo.pkgName}}', subFolder: '{{=it.messageInfo.subFolder}}', interfaceName: '{{=it.messageInfo.interfaceName}}'};
  }

  get refObject() {
    {{~ it.spec.fields :field}}
    {{? !isPrimitivePackage(it.spec.baseType) && !field.type.isPrimitiveType}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? !isPrimitivePackage(it.spec.baseType) && isString(field.type)}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?? field.type.isArray}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?}}    
    {{~}}
    return this._refObject;
  }

{{~ it.spec.fields :field}}
  get {{=field.name}}() {
  {{? isPrimitive(field.type) && isPrimitivePackage(it.spec.baseType)}}
    return this._refObject.{{=field.name}};
  {{?? isStruct(field.type) || isString(field.type)}}
    return this._wrapperFields.{{=field.name}};
  {{?? isPrimitiveArray(field.type)}}
    let arr = this._refObject.{{=field.name}}.data;
    arr.length = this._refObject.{{=field.name}}.size;
    return arr.toArray();
  {{?? true}}
    return this._refObject.{{=field.name}};
  {{?}}
  }

  set {{=field.name}}(value) {
  {{? isString(field.type) && it.spec.msgName === 'String'}}
    this._refObject.size = value.length;
    this._refObject.capacity = value.length + 1;
    this._refObject.data = value;
  {{?? isStruct(field.type) || isString(field.type)}}
    if (! value instanceof {{=getWrapperNameByType(field.type)}}) {
      throw new TypeError('Invalid argument: should provide "{{=getWrapperNameByType(field.type)}}" to ".{{=field.name}}" setter');
    }
    this._wrapperFields.{{=field.name}} = value;
  {{?? isPrimitiveArray(field.type)}}
    this._wrapperFields['{{=field.name}}'].setWrappersArray(value);
  {{?? true}}
    this._refObject.{{=field.name}} = value;
  {{?}}
  }
{{~}}

  copy(other) {
    this._refObject = new {{=refObjectType}}(other._refObject.toObject());
  }

}

// Define the wrapper of array class
class {{=arrayWrapper}} {
  constructor(size = 0) {
    this._resize(size);
    this._refObject = new {{=refObjectArrayType}};
  }

  toRawROS() {
    return this._refObject.ref();
  }
  
  setWrappersArray(array) {
    this._refArray = new {{=refArrayType}}(array.length);

    array.forEach((value, index) => {
      let wrapper = new {{=objectWrapper}}();
      wrapper.data = value;
      this._refArray[index] = wrapper.refObject;
    });

    this._refObject.size = array.length;
    this._refObject.capacity = array.length;
    this._refObject.data = this._refArray.buffer;
  }

  get values() {
    return this._wrappersArray.values();
  }

  get data() {
    return this._wrappersArray;
  }

  get size() {
    return this._wrappersArray.length;
  }

  set size(v) {
    if (typeof v != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.size setter');
      return;
    }

    return this._resize(v);
  }

  get capacity() {
    return this._wrappersArray.length;
  }

  set capacity(v) {
    if (typeof v != 'number') {
      throw new TypeError('Invalid argument: should provide a number to {{=arrayWrapper}}.capacity setter');
      return;
    }

    return this._resize(v);
  }

  get refObject() {
    {{~ it.spec.fields :field}}
    {{? !isPrimitivePackage(it.spec.baseType)}}
    this._refObject.{{=field.name}} = this._wrapperFields.{{=field.name}}.refObject;
    {{?}}
    {{~}}
    return this._refObject;
  }

  _resize(size) {
    if (size < 0) {
      throw new RangeError('Invalid argument: should provide a positive number');
      return;
    }

    this._refArray = new ArrayType({{=refObjectType}});
    this._refArray.size = size;
    this._refArray.capacity = size;

    this._wrappersArray = new Array();
    for (let i = 0; i < size; i++) {
      this._wrappersArray.push(new {{=objectWrapper}}());
    }
  }

  copy(other) {
    this._resize(other.size);

    // Array deep copy
    for (let i = 0; i < this._wrappersArray.length; ++ i) {
      this._wrappersArray[i].copy(other._wrappersArray[i]);
    }
  }
}

{{? it.spec.constants != undefined && it.spec.constants.length}}
// Define constants ({{=it.spec.constants.length}} in total)
{{~ it.spec.constants :c}}
Object.defineProperty({{=objectWrapper}}, "{{=c.name}}", {value: {{=c.value}}, writable: false, enumerable: true, configurable: true});
{{~}}
{{?}}

module.exports = {{=objectWrapper}};

/*
 * The following is the original spec object coming from parser:
{{=it.json}}
*/
